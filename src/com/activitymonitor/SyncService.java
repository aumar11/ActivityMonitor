//
// SyncService.java
// SocialGatherer
//
// Created by Stephen Bell
// Modified by Jakub Konka on 30/04/2012
// Copyright (c) 2012 University of Strathclyde. All rights reserved.
//

package com.activitymonitor;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.net.URI;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.http.HttpEntity;
import org.apache.http.HttpException;
import org.apache.http.HttpHost;
import org.apache.http.HttpRequest;
import org.apache.http.HttpRequestInterceptor;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.NameValuePair;
import org.apache.http.StatusLine;
import org.apache.http.auth.AuthSchemeRegistry;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.AuthState;
import org.apache.http.auth.Credentials;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.protocol.ClientContext;
import org.apache.http.client.utils.URIUtils;
import org.apache.http.client.utils.URLEncodedUtils;
import org.apache.http.entity.mime.MultipartEntity;
import org.apache.http.entity.mime.content.StringBody;
import org.apache.http.impl.auth.BasicScheme;
import org.apache.http.impl.auth.BasicSchemeFactory;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.CoreProtocolPNames;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.protocol.ExecutionContext;
import org.apache.http.protocol.HttpContext;
import org.apache.http.util.EntityUtils;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.os.IBinder;
import android.os.PowerManager;
import android.telephony.TelephonyManager;
import android.util.Log;

/**
 * This class performs the synchronisation with a central server. It contacts
 * the server using HTTPS, and pushes new data in the CSV format compressed with
 * GNU zip to the server.
 * @author Stephen Bell
 * @author Jakub Konka
 * @version 1.0
 */
public class SyncService extends Service {
	/**
	 * Tag for use in logging and debugging the output generated by this class.
	 */
	public final static String TAG = "SyncService";
	/**
	 * Encoding type.
	 */
	private final static String CHARSET = "UTF-8";
	/**
	 * Relative path to the PHP script accepting and parsing data on the server.
	 */
	private final static String DATA_PATH = "/activities/syncData.php";
	/**
	 * Server host name.
	 */
	private final static String HOST = "10.100.0.70";
	/**
	 * Relative path to the PHP script returning the latest data id on the server.
	 */
	private final static String LATEST_PATH = "/activities/sendLatest.php";
	/**
	 * Connection timeout param.
	 */
	private final static int CONNECTION_TIMEOUT = 10000;
	/**
	 * Maximum number of network retries param.
	 */
	private final static int MAXIMUM_NETWORK_RETRIES = 3;
	/**
	 * Network port param (443 for TLS).
	 */
	private final static int PORT = 80;
	/**
	 * Consecutive pushing retry delay values.
	 */
	private final static int[] NETWORK_RETRY_DELAY = new int[] {5000, 10000, 20000};


	private boolean mHasError = false;

	private PowerManager mPowerManager;
	private PowerManager.WakeLock mWakeLock;

	SyncThread mSyncThread; 

	/**
	 * Called when the service is first created.
	 */
	@Override
	public void onCreate() {
		super.onCreate();
		Log.i(TAG, "Creating service");
		mPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);
		mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
		mWakeLock.acquire();
	}

	/**
	 * Called when the service is started.
	 */                      
	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
		mSyncThread = new SyncThread();
		mSyncThread.start();
		return 0;
	}

	/**
	 * Called when the service is destroyed.
	 */
	@Override
	public void onDestroy() {
		super.onDestroy();
		Log.i(TAG, "Releasing WakeLock");
		mWakeLock.release();
	}

	/**
	 * @param intent {@link android.content.Intent}
	 * @return null.
	 */
	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}

	/**
	 * Updates the server with new data prepared as a CSV file, and compressed
	 * using GNU zip.
	 * @param mArray {@code byte} array.
	 */
	private int updateServer(byte[] mArray) {
		Log.i(TAG, "Synchronising new interactions with Sederunt server");
		try {
			FixedInputStreamBody fsb = new FixedInputStreamBody(new ByteArrayInputStream(mArray),
					mArray.length,
					"application/octet-stream",
					"test.txt");
			MultipartEntity multipartEntity = new MultipartEntity();
			multipartEntity.addPart("data", fsb);

			URI uri = URIUtils.createURI("http", SyncService.HOST, SyncService.PORT, DATA_PATH, null, null);
			HttpPost httpPost = new HttpPost(uri);
			httpPost.setEntity(multipartEntity);
			DefaultHttpClient httpClient = new DefaultHttpClient(new BasicHttpParams());
			HttpConnectionParams.setConnectionTimeout(httpClient.getParams(), CONNECTION_TIMEOUT);

		//	httpClient.getParams().setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE , true);            

			HttpResponse httpResponse = httpClient.execute(httpPost);
			HttpEntity entity = httpResponse.getEntity();
			Log.i(TAG, EntityUtils.toString(entity, SyncService.CHARSET));
			StatusLine status = httpResponse.getStatusLine();
			int statusCode = status.getStatusCode();
			if (statusCode == HttpStatus.SC_OK) {
				Log.i(TAG, "Updated successfully");
				return 0;
			} else {
				Log.i(TAG, "Statuscode: " + statusCode);
				mHasError = true;
				return -1;
			}
		} catch (Exception e) {
			Log.i(TAG, "Exception occurred: " + e.getMessage());
			mHasError = true;
			return -1;
		}
	}

	/**
	 * Private nested class implementing cancelable thread. This class performs
	 * the synchronisation with the server using a separate worker thread (to offload
	 * the UI thread).
	 * @see CancelableThread
	 */
	private class SyncThread extends CancelableThread {
		/**
		 * Constructs object of type {@code SyncThread}.
		 */
		public SyncThread() {
			super("SyncThread");
		}

		/**
		 * Starts the thread. The thread is cancelled after the method hits the end of its code.
		 */
		public void run() {
			Log.i(SyncService.TAG, "Synchronising device with external server");
			int tryCount = 0;
			while (tryCount < MAXIMUM_NETWORK_RETRIES + 1) {
				Log.i(SyncService.TAG, "Attempt: " + (tryCount + 1));
				String latest = new String();
				DefaultHttpClient httpClient = new DefaultHttpClient(new BasicHttpParams());
				HttpConnectionParams.setConnectionTimeout(httpClient.getParams(), CONNECTION_TIMEOUT);        
				try {
					URI uri = URIUtils.createURI("http", SyncService.HOST, SyncService.PORT, LATEST_PATH, null, null);
					Log.i(SyncService.TAG, "URI: " + uri);
					HttpGet httpGet = new HttpGet(uri);                        
					HttpResponse httpResponse = httpClient.execute(httpGet);
					int statusCode = httpResponse.getStatusLine().getStatusCode();
					if (statusCode == HttpStatus.SC_OK) {
						HttpEntity httpEntity = httpResponse.getEntity();
						if (httpEntity != null) {
							latest = EntityUtils.toString(httpEntity, SyncService.CHARSET);
							if(latest.equals(""))
								latest = "0";
							Log.i(SyncService.TAG, "Latest ID on server: " + latest);
						} else {
							Log.d(SyncService.TAG, "Server did not respond");
							mHasError = true;
						}
					} else {
						Log.d(SyncService.TAG, "Server responded with status code: " + statusCode);
						mHasError = true;
					}
				} catch (Exception e) {
					Log.d(SyncService.TAG, "Exception occurred: " + e.getMessage());
					mHasError = true;
				}               
				if (!mHasError) {
					SampleDB db = new SampleDB(SyncService.this);
					Cursor cursor = db.getLatestSamples(Integer.parseInt(latest));
					String s;
					if (cursor.getCount() > 0) {
						s = Stringer.csvStringFromCursor(cursor);
						Log.i(SyncService.TAG, s);
					} else {
						Log.i(SyncService.TAG, "No new interactions to store");
						break;
					}
					byte[] zip = null;
					try {
						zip = Gzipper.zip(s.getBytes(SyncService.CHARSET));
					} catch (Exception e) {}
					Log.i(SyncService.TAG, "Zip: " + zip);
					if (zip != null) 
						updateServer(zip);
				}
				if (mHasError) {
					tryCount++;
					if (tryCount >= MAXIMUM_NETWORK_RETRIES)
						break;
					Log.i(SyncService.TAG, "Incrementing try count to " + tryCount + " and sleeping for " + NETWORK_RETRY_DELAY[tryCount-1]);
					mHasError = false;
					try {
						Thread.sleep(NETWORK_RETRY_DELAY[tryCount - 1]);
					} catch (InterruptedException e) {}
				} else {
					break;
				}
			}
			if (!mHasError) 
				Log.i(SyncService.TAG, "Server updated successfully");
			else 
				Log.i(SyncService.TAG, "Failed to update the server");
			stopSelf();
		}
	}   
}