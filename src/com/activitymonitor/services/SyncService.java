//
// SyncService.java
// SocialGatherer
//
// Created by Stephen Bell
// Modified by Jakub Konka on 30/04/2012
// Copyright (c) 2012 University of Strathclyde. All rights reserved.
//

package com.activitymonitor.services;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.URI;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Date;
import java.util.Enumeration;
import java.util.List;

import org.apache.http.HttpEntity;
import org.apache.http.HttpException;
import org.apache.http.HttpHost;
import org.apache.http.HttpRequest;
import org.apache.http.HttpRequestInterceptor;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.NameValuePair;
import org.apache.http.StatusLine;
import org.apache.http.auth.AuthSchemeRegistry;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.AuthState;
import org.apache.http.auth.Credentials;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.protocol.ClientContext;
import org.apache.http.client.utils.URIUtils;
import org.apache.http.client.utils.URLEncodedUtils;
import org.apache.http.entity.mime.MultipartEntity;
import org.apache.http.entity.mime.content.StringBody;
import org.apache.http.impl.auth.BasicScheme;
import org.apache.http.impl.auth.BasicSchemeFactory;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.CoreProtocolPNames;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.protocol.ExecutionContext;
import org.apache.http.protocol.HttpContext;
import org.apache.http.util.EntityUtils;

import com.activitymonitor.database.SampleDB;
import com.activitymonitor.helpers.CancelableThread;
import com.activitymonitor.helpers.FixedInputStreamBody;
import com.activitymonitor.helpers.Gzipper;
import com.activitymonitor.helpers.Stringer;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.IBinder;
import android.os.PowerManager;
import android.telephony.TelephonyManager;
import android.util.Log;

/**
 * This class performs the synchronisation with a central server. It contacts
 * the server using HTTPS, and pushes new data in the CSV format compressed with
 * GNU zip to the server.
 * @author Stephen Bell
 * @author Jakub Konka
 * @version 1.0
 */
public class SyncService extends Service {
	/**
	 * Tag for use in logging and debugging the output generated by this class.
	 */
	public final static String TAG = "SyncService";
	/**
	 * Encoding type.
	 */
	private final static String CHARSET = "UTF-8";
	/**
	 * Relative path to the PHP script accepting and parsing data on the server.
	 */
	private final static String DATA_SAMPLE_PATH = "/activities/syncData.php";
	/**
	 * Relative path to the PHP script accepting and parsing data on the server.
	 */
	private final static String DATA_NAMES_PATH = "/activities/syncNames.php";
	/**
	 * Server host name.
	 */
	private static String HOST = "10.200.0.214";
	/**
	 * Relative path to the PHP script returning the latest data id on the server.
	 */
	private final static String LATEST_SAMPLE_PATH = "/activities/sendLatest.php";

	/**
	 * Connection timeout param.
	 */
	private final static int CONNECTION_TIMEOUT = 10000;
	/**
	 * Maximum number of network retries param.
	 */
	private final static int MAXIMUM_NETWORK_RETRIES = 3;
	/**
	 * Network port param (443 for TLS).
	 */
	private final static int PORT = 80;
	/**
	 * Consecutive pushing retry delay values.
	 */
	private final static int[] NETWORK_RETRY_DELAY = new int[] {5000, 10000, 20000};


	private boolean mHasError = false;

	private PowerManager mPowerManager;
	private PowerManager.WakeLock mWakeLock;

	SyncThread mSyncThread; 

	/**
	 * Called when the service is first created.
	 */
	@Override
	public void onCreate() {
		super.onCreate();
		Log.i(TAG, "Creating service");
		mPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);
		mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
		mWakeLock.acquire();
//		getIpAddr();
	}

	/**
	 * Called when the service is started.
	 */                      
	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
		mSyncThread = new SyncThread();
		mSyncThread.start();
		return 0;
	}

	/**
	 * Called when the service is destroyed.
	 */
	@Override
	public void onDestroy() {
		super.onDestroy();
		Log.i(TAG, "Releasing WakeLock");
		mWakeLock.release();
	}

	/**
	 * @param intent {@link android.content.Intent}
	 * @return null.
	 */
	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}

	/**
	 * Updates the server with new data prepared as a CSV file, and compressed
	 * using GNU zip.
	 * @param namesArray {@code byte} array.
	 */
	private int updateServer(byte[] namesArray,boolean updateNames, byte[] samplesArray,boolean updateSamples) {
		Log.i(TAG, "Synchronising new interactions with Sederunt server");
		String uN ="";
		String uS = "";
		try {
			FixedInputStreamBody fsb = new FixedInputStreamBody(new ByteArrayInputStream(namesArray),
					namesArray.length,
					"application/octet-stream",
					"test.txt");

			FixedInputStreamBody fsb2 = new FixedInputStreamBody(new ByteArrayInputStream(samplesArray),
					samplesArray.length,
					"application/octet-stream",
					"test1.txt");
			if(updateNames){
				uN = "true";
			}
			else{
				uN = "false";
			}

			if(updateSamples){
				uS = "true";
			}
			else{
				uS = "false";
			}

			MultipartEntity multipartEntity = new MultipartEntity();
			multipartEntity.addPart("names", fsb);
			multipartEntity.addPart("samples", fsb2);
			multipartEntity.addPart("uN", new StringBody(uN, Charset.forName(SyncService.CHARSET)));
			multipartEntity.addPart("uS", new StringBody(uS, Charset.forName(SyncService.CHARSET)));



			URI uri = URIUtils.createURI("http", SyncService.HOST, SyncService.PORT, DATA_SAMPLE_PATH, null, null);
			HttpPost httpPost = new HttpPost(uri);
			httpPost.setEntity(multipartEntity);
			DefaultHttpClient httpClient = new DefaultHttpClient(new BasicHttpParams());
			HttpConnectionParams.setConnectionTimeout(httpClient.getParams(), CONNECTION_TIMEOUT);
			Log.i(TAG,"are we getting in here?");

			HttpResponse httpResponse = httpClient.execute(httpPost);
			HttpEntity entity = httpResponse.getEntity();
			Log.i(TAG, EntityUtils.toString(entity, SyncService.CHARSET));
			StatusLine status = httpResponse.getStatusLine();
			int statusCode = status.getStatusCode();
			if (statusCode == HttpStatus.SC_OK) {
				Log.i(TAG, "Updated successfully" + DATA_SAMPLE_PATH);
				return 0;
			} else {
				Log.i(TAG, "Statuscode: " + statusCode);
				mHasError = true;
				return -1;
			}
		} catch (Exception e) {
			Log.i(TAG, "Exception occurred: " + e.getMessage());
			mHasError = true;
			return -1;
		}


	}

//	public String getIpAddr() {
//		   WifiManager wifiManager = (WifiManager) getSystemService(WIFI_SERVICE);
//		   WifiInfo wifiInfo = wifiManager.getConnectionInfo();
//		   int ip = wifiInfo.getIpAddress();
//		   int a = (ip & 0xff);
//		   int b = (ip >> 8 & 0xff);
//		   int c = (ip >> 16 & 0xff);
//		   int d = (ip >> 24 & 0xff);
//
//		   String ipString = String.format("%d.%d.%d.%d",a,b,c,d);
//		   Log.i(TAG,"IP address: "+ ipString);
//		   return ipString;
//		}

	/**
	 * Private nested class implementing cancelable thread. This class performs
	 * the synchronisation with the server using a separate worker thread (to offload
	 * the UI thread).
	 * @see CancelableThread
	 */
	private class SyncThread extends CancelableThread {
		/**
		 * Constructs object of type {@code SyncThread}.
		 */
		public SyncThread() {
			super("SyncThread");
		}

		/**
		 * Starts the thread. The thread is cancelled after the method hits the end of its code.
		 */
		public void run() {
			Log.i(SyncService.TAG, "Synchronising device with external server");
			int tryCount = 0;
			String latestNameID = "";
			String latestSampleID = "";
			while (tryCount < MAXIMUM_NETWORK_RETRIES + 1) {
				Log.i(SyncService.TAG, "Attempt: " + (tryCount + 1));
				String latestData = new String();
				DefaultHttpClient httpClient = new DefaultHttpClient(new BasicHttpParams());
				HttpConnectionParams.setConnectionTimeout(httpClient.getParams(), CONNECTION_TIMEOUT);        
				try {
					URI uri = URIUtils.createURI("http", SyncService.HOST, SyncService.PORT, LATEST_SAMPLE_PATH, null, null);
					Log.i(SyncService.TAG, "URI: " + uri);
					HttpGet httpGet = new HttpGet(uri);                        
					HttpResponse httpResponse = httpClient.execute(httpGet);
					int statusCode = httpResponse.getStatusLine().getStatusCode();
					if (statusCode == HttpStatus.SC_OK) {
						HttpEntity httpEntity = httpResponse.getEntity();
						if (httpEntity != null) {
							latestData = EntityUtils.toString(httpEntity, SyncService.CHARSET);
							String[] data = latestData.split("\\<br\\>");

							latestNameID = data[0];
							latestSampleID = data[1];	

							Log.i(SyncService.TAG, "Latest ID on activity_names: " + latestNameID);
							Log.i(SyncService.TAG, "Latest ID on sample: " + latestSampleID);

						} else {
							Log.d(SyncService.TAG, "Server did not respond");
							mHasError = true;
						}
					} else {
						Log.d(SyncService.TAG, "Server responded with status code: " + statusCode);
						mHasError = true;
					}
				} catch (Exception e) {
					Log.d(SyncService.TAG, "Exception occurred: " + e.getMessage());
					mHasError = true;
				}               
				if (!mHasError) {
					SampleDB db = new SampleDB(SyncService.this);
					Cursor cursorName = db.getLatestNames(Integer.parseInt(latestNameID));
					Cursor cursorSample = db.getLatestSamples(Integer.parseInt(latestSampleID));
					String csvNames ="";
					String csvSamples;
					boolean updateNames = false;
					boolean updateSamples = false;

					if (cursorName.getCount() > 0) {
						csvNames = Stringer.csvStringFromCursor(cursorName);
						cursorName.close();
						Log.i(SyncService.TAG, "csv names " + csvNames);
					} 
					if (cursorSample.getCount() > 0) {
						csvSamples = Stringer.csvStringFromCursor(cursorSample);
						cursorSample.close();
						Log.i(SyncService.TAG, "csv samples " + csvSamples);
					} else {
						Log.i(SyncService.TAG, "No new interactions to store");
						break;
					}
					byte[] zipNames = null;
					byte[] zipSamples = null;
					try {
						zipNames = Gzipper.zip(csvNames.getBytes(SyncService.CHARSET));
						zipSamples = Gzipper.zip(csvSamples.getBytes(SyncService.CHARSET));
					} catch (Exception e) {}
					Log.i(SyncService.TAG, "ZipNames: " + zipNames);
					Log.i(SyncService.TAG, "ZipSamples: " + zipSamples);
					if (zipNames == null || csvNames==""){ 
						zipNames = new byte[]{0};
					}
					else
						updateNames = true;
					if (zipSamples == null){
						zipSamples = new byte[]{0};
					}
					else
						updateSamples = true;

					updateServer(zipNames,updateNames,zipSamples,updateSamples);

				}
				if (mHasError) {
					tryCount++;
					if (tryCount >= MAXIMUM_NETWORK_RETRIES)
						break;
					Log.i(SyncService.TAG, "Incrementing try count to " + tryCount + " and sleeping for " + NETWORK_RETRY_DELAY[tryCount-1]);
					mHasError = false;
					try {
						Thread.sleep(NETWORK_RETRY_DELAY[tryCount - 1]);
					} catch (InterruptedException e) {}
				} else {
					break;
				}
			}
			if (!mHasError) 
				Log.i(SyncService.TAG, "Server updated successfully");
			else 
				Log.i(SyncService.TAG, "Failed to update the server");
			stopSelf();
		}
	}   
}